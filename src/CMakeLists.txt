#============= 1. FIND PACKAGES WE DEPEND ON =========================

find_package(HPX)

if(NOT HPX_FOUND)
  if(NOT DEFINED BOOST_ROOT)
    # deduce Boost location from environment (e.g. on woody.rrze.uni-erlangen.de)
    set(BOOST_ENV_LIBDIR "$ENV{BOOST_LIBDIR}")
    if(BOOST_ENV_LIBDIR)
      set(Boost_NO_SYSTEM_PATHS true)
      set(BOOST_ROOT "$ENV{BOOST_LIBDIR}/../")
      set(Boost_LIBRARY_DIRS "$ENV{BOOST_LIBDIR}")
      set(Boost_INCLUDE_DIR  "$ENV{BOOST_INCDIR}")
    endif()
  endif()

  # mandatory Boost libs go into the first line, optional ones into
  # their own call. This avoids leaving out any available lib during
  # link time. The reason for this ugly multi-stage discovery is the
  # following: since CMAKE 2.8.11 each call to find_package(Boost...)
  # will reset Boost_LIBRARIES.
  find_package(Boost REQUIRED COMPONENTS date_time filesystem system)
  set(ALL_BOOST_LIBS "${Boost_LIBRARIES}")
  find_package(Boost COMPONENTS serialization)
  set(ALL_BOOST_LIBS "${ALL_BOOST_LIBS};${Boost_LIBRARIES}")
  find_package(Boost COMPONENTS thread)
  set(ALL_BOOST_LIBS "${ALL_BOOST_LIBS};${Boost_LIBRARIES}")
  find_package(Boost COMPONENTS move)
  set(ALL_BOOST_LIBS "${ALL_BOOST_LIBS};${Boost_LIBRARIES}")
else()
  # If HPX was found, we use the Boost libraries found by HPX
  set(ALL_BOOST_LIBS
    ${HPX_BOOST_DATE_TIME_LIBRARY}
    ${HPX_BOOST_FILESYSTEM_LIBRARY}
    ${HPX_BOOST_SYSTEM_LIBRARY}
    ${HPX_BOOST_SERIALIZATION_LIBRARY}
    ${HPX_BOOST_THREAD_LIBRARY}
  )
  set(Boost_DATE_TIME_FOUND true)
  set(Boost_FILESYSTEM_FOUND true)
  set(Boost_SYSTEM_FOUND true)
  set(Boost_SERIALIZATION_FOUND true)
  set(Boost_THREAD_FOUND true)
endif()

find_package(Boost COMPONENTS mpi)
set(Boost_MPI_LIBRARIES "${Boost_LIBRARIES}")

# search for external LibFlatArray, but -- if none was found -- default to bundled version:
find_package(libflatarray QUIET)
if(NOT libflatarray_FOUND)
  set(libflatarray_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../lib/libflatarray")
  find_package(libflatarray)
  # add this include paths only to BUILD_INCLUDE_DIRECTORIES as must
  # not be exported during install in any case (the build tree must be
  # considered a temporary directory, and CMake would complain).
  list(APPEND BUILD_INCLUDE_DIRECTORIES ${libflatarray_INCLUDE_DIR})
else()
  # if LibFlatArray was found outside, we'll assume we're not using
  # the bundled version and we need export the relevant directory:
  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${libflatarray_INCLUDE_DIR})
endif()

# currently VisIt only supports Python 2.x. This (undocumented?)
# feature of CMake allows us to avoid Python 3.y.
set(PythonLibs_FIND_VERSION 2)
# setting this variable is required since CMake 3.0
set(PythonLibs_FIND_VERSION_MAJOR 2)

find_package(CUDA)
find_package(OpenCL)
find_package(MPI)
find_package(OpenCV)
find_package(OpenMP)
find_package(PythonLibs)
find_package(Ruby)
find_package(SCOTCH)
find_package(Silo)
find_package(Qt4 COMPONENTS QtOpenGL QtGui QtCore)
find_package(VisIt)

# if a package was not found it's safer to set the corresponding
# variable to false, this avoids undefined/unintended behavior in some
# cases.
if(NOT DEFINED Boost_SERIALIZATION_FOUND)
  set(Boost_SERIALIZATION_FOUND false)
endif()

if(NOT DEFINED Boost_MPI_FOUND)
  set(Boost_MPI_FOUND false)
endif()

if(NOT DEFINED Boost_MOVE_FOUND)
  set(Boost_MOVE_FOUND false)
endif()

if(NOT DEFINED CUDA_FOUND)
  set(CUDA_FOUND false)
endif()

if(NOT DEFINED HPX_FOUND)
  set(HPX_FOUND false)
endif()

if(NOT DEFINED OpenCV_FOUND)
  set(OpenCV_FOUND false)
endif()

if(NOT DEFINED OpenMP_FOUND)
  set(OpenMP_FOUND false)
endif()

if(NOT DEFINED PYTHONLIBS_FOUND)
  set(PYTHONLIBS_FOUND false)
endif()

if(NOT DEFINED QT4_FOUND)
  set(QT4_FOUND false)
endif()

if(NOT DEFINED RUBY_FOUND)
  set(RUBY_FOUND false)
endif()

if(NOT DEFINED SCOTCH_FOUND)
  set(SCOTCH_FOUND false)
endif()

if(NOT DEFINED Silo_FOUND)
  set(Silo_FOUND false)
endif()

#============= 2. DETECT DEFAULTS ====================================
set(RELEASE false)
detect_distro()

# compute default flags:
set(DEFAULT_FLAGS "${DEFAULT_FLAGS} -Wall -Wno-sign-promo -Wnon-virtual-dtor")

check_cxx_compiler_flag("-march=native" SUPPORTS_MARCH_NATIVE)
if(SUPPORTS_MARCH_NATIVE AND NOT APPLE)
  set(DEFAULT_FLAGS "${DEFAULT_FLAGS} -march=native")
endif()

# configure whether the dreaded typemap-generator will run:
set(DEFAULT_TYPEMAP_GENERATION false)
if(NOT RELEASE)
  set(DEFAULT_TYPEMAP_GENERATION ${RUBY_FOUND})
endif()

execute_process(
  COMMAND uname -m
  OUTPUT_VARIABLE MACHINE_ARCH
  ERROR_QUIET)

set(AMD64_LINUX false)
if (MACHINE_ARCH MATCHES "x86_64")
  set(AMD64_LINUX true)
endif()

#============= 3. CONFIGURABLE BUILD OPTIONS =========================
add_config_option(ADDITIONAL_COMPILE_FLAGS "Add these flags when compiling." "${DEFAULT_FLAGS}" false)

add_config_option(CMAKE_BUILD_TYPE "Sets the compile/link options, e.g. Debug, Release... Refer to the cmake documentation for more details." "Release" false)

add_config_option(CAKE_CXX_COMPILER "Select the C++ compiler" ${CMAKE_CXX_COMPILER} false)

add_config_option(CMAKE_INSTALL_PREFIX "Path for installation" "/usr/local" false)

# setting DEBUG_LEVEL to " 0" is a hack to ensure it's included in the config header, as just "0" would evaluate to false (see util.cmake)
add_config_option(DEBUG_LEVEL "Configure the amount/verbosity of debug output" " 0" true)

add_config_option(LIB_LINKAGE_TYPE "Controls which type of library to build. Suggested: SHARED on Linux (creates a shared object \"libgeodecomp.so\"), STATIC should work for builds on Cray and Windows." "SHARED" false)

add_config_option(LIB_DIR "Library subdirectory (e.g. lib, lib32, lib64), useful for multilib builds" "lib" false)

add_config_option(LIMIT_TESTS "Limit the directories of tests to run. Only tests matching the specified pattern will be run." false false)

add_config_option(UNITEXEC "May be used to specify a wrapper which then calls a unit test executable. Handy if for instance the unit tests shall be run on a remote machine." "" false)

add_config_option(WITH_BOOST_ASIO "Some Boost distributions ship too old versions of ASIO which are not compatible with LibGeoDecomp. Use this flag to switch ASIO-related code off." true true)

add_config_option(WITH_BOOST_MOVE "Enable/disable Boost.Move for move semantics (e.g. to avoid copies of vectors)." ${Boost_MOVE_FOUND} true)

add_config_option(WITH_BOOST_MPI "Enable/disable Boost.MPI related code." ${Boost_MPI_FOUND} true)

add_config_option(WITH_BOOST_SERIALIZATION "Explicitly disable Boost.Serialization, which isn't available on some machines (e.g. woody.rrze.uni-erlangen.de). Don't do this if you need the HPX backend." ${Boost_SERIALIZATION_FOUND} true)

add_config_option(WITH_CUDA "Enable modules which harness Nvidia CUDA GPUs" ${CUDA_FOUND} true)

add_config_option(WITH_FORTRAN "Build Fortran examples/utilities, too" false true)

add_config_option(WITH_HPX "Build those modules which require HPX" ${HPX_FOUND} true)

add_config_option(WITH_INTRINSICS "Switch on/off the code parts which require SSE or AVX intrinsics" ${AMD64_LINUX} true)

add_config_option(WITH_LAX_VISIT_TESTS "Remove some of the stricter assertions from VisIt related unit tests -- VisIt sometimes produces erroneous results when running on a remote machine (e.g. for autobuilds)" false true)

add_config_option(WITH_LIBPTHREAD "Use this option to avoid linking against libpthread but instead adding -pthread to the compiler options (the former is required for CUDA when using nvcc, the latter for Android with gcc)." true false)

add_config_option(WITH_MPI "If set, all MPI related components will be built. This option is required for the MPI unit tests." ${MPI_FOUND} true)

add_config_option(WITH_OPENCL "Enable modules for delegating to OpenCL devices" false true)

add_config_option(WITH_OPENCV "Build those modules which require OpenCV" ${OpenCV_FOUND} false)

add_config_option(WITH_QT "Build example codes which rely on QT4 for the GUI" ${QT4_FOUND} true)

add_config_option(WITH_SCOTCH "Enables LibGeoDecomp to use Scotch and PT-Scotch for domain decomposition." ${SCOTCH_FOUND} true)

add_config_option(WITH_SILO "Silo is a flexible output library developed by LLNL." ${Silo_FOUND} true)

add_config_option(WITH_THREADS "Lets you control whether we'll use threads (e.g. boost::thread)" true true)

add_config_option(WITH_TYPEMAPS "Controls whether the build system should regenerate typemaps.{h,cpp}. Requires Ruby and some Unix tools." ${DEFAULT_TYPEMAP_GENERATION} false)

add_config_option(WITH_VISIT "Activate code parts which use VisitWriter and SerialVisitWriter" ${VISIT_FOUND} true)

print_options()
dump_config("config.h")

#============= 4. GENERAL CONFIGURATION ==============================
# LIBDIRS is used to find source files and headers
set(LIBDIRS communication io geometry geometry/partitions loadbalancer misc parallelization parallelization/hiparsimulator parallelization/hiparsimulator parallelization/hpxsimulator storage)
# AUXDIRS lists auxiliary directories to be included in the main
# build. They may for instance include additionally libraries to be
# linked into the main lib.
set(AUXDIRS)
# set(AUXDIRS misc/testbed/cell/spustuff)
set(SUBDIRS communication examples io geometry loadbalancer misc parallelization storage testbed)

set(CXX_TEST_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../lib/cxxtest")
set(CMAKE_C_FLAGS   "${CMAKE_C_FLAGS}   ${ADDITIONAL_COMPILE_FLAGS}")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ADDITIONAL_COMPILE_FLAGS}")

list(APPEND BUILD_INCLUDE_DIRECTORIES ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_BINARY_DIR})
generate_sourcelists("./")

if(WITH_BOOST_MPI)
  set(ALL_BOOST_LIBS "${ALL_BOOST_LIBS};${Boost_MPI_LIBRARIES}")
endif()

if(WITH_CUDA)
  set(CUDA_NVCC_FLAGS "--gpu-architecture=sm_20")
endif()

if(WITH_FORTRAN)
  enable_language(Fortran)
endif()

if(WITH_HPX)
  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${HPX_INCLUDE_DIRS})
  link_directories(${HPX_LIBRARY_DIR})
  add_definitions(-DHPX_LIMIT=10 ${HPX_CXX_COMPILE_FLAGS})
  set(HPX_RPATH "${CMAKE_INSTALL_PREFIX}/${LIB_DIR}/hpx:${CMAKE_BINARY_DIR}/${LIB_DIR}/hpx:${CMAKE_BINARY_DIR}/src")
endif()

if(WITH_MPI)
  add_definitions(${MPI_COMPILE_FLAGS})
  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${MPI_INCLUDE_PATH})
endif()

if(WITH_SCOTCH)
  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${SCOTCH_INCLUDE_DIRS})
endif()

if(WITH_SILO)
  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${Silo_INCLUDE_DIR})
endif()

if(WITH_THREADS)
  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
endif()

list(APPEND INSTALL_INCLUDE_DIRECTORIES ${Boost_INCLUDE_DIRS})

#============= 5. SANITY CHECKS ======================================
# import settings detected by packages to decouple from their
# interfaces, perform sanity checks to match selected options and
# detected environment...
if(WITH_BOOST_MPI AND NOT Boost_MPI_FOUND)
  message(FATAL_ERROR "WITH_BOOST_MPI selected, but Boost.MPI library not found")
endif()

if(WITH_BOOST_MOVE AND NOT Boost_MOVE_FOUND)
  message(FATAL_ERROR "WITH_BOOST_MOVE selected, but Boost.Move library not found")
endif()

if(WITH_BOOST_SERIALIZATION AND NOT Boost_SERIALIZATION_FOUND)
  message(FATAL_ERROR "WITH_BOOST_SERIALIZATION selected, but Boost.Serialization library not found")
endif()

if(WITH_CUDA AND NOT CUDA_FOUND)
  message(FATAL_ERROR "WITH_CUDA selected, but could not find the NVIDIA CUDA toolkit.")
endif()

if(WITH_HPX AND NOT HPX_FOUND)
  message(FATAL_ERROR "WITH_HPX selected but could not find HPX. Specify HPX_ROOT to point to your HPX installation.")
endif()

if(WITH_HPX AND NOT Boost_SERIALIZATION_FOUND)
  message(FATAL_ERROR "WITH_HPX selected but Boost.Serialization is missing. Is your Boost installation incomplete?")
endif()

if(WITH_MPI)
  if(NOT MPI_FOUND)
    message(FATAL_ERROR "WITH_MPI selected, but could find no MPI implementation.")
  endif()

  if(NOT MPIEXEC)
    message(FATAL_ERROR "WITH_MPI selected, but mpiexec not found.")
  endif()
endif()

if(WITH_OPENCL AND NOT OPENCL_FOUND)
  message(FATAL_ERROR "WITH_OPENCL selected, but could not find any OpenCL library.")
endif()

if(WITH_OPENCV AND NOT OpenCV_FOUND)
  message(FATAL_ERROR "WITH_OPENCV selected, but could not find OpenCV.")
endif()

if(WITH_QT AND NOT QT4_FOUND)
  message(FATAL_ERROR "WITH_QT selected, but could not find QT4")
endif()

if(WITH_SCOTCH AND NOT SCOTCH_FOUND)
  message(FATAL_ERROR "WITH_SCOTCH selected but no installation of Scotch could be found.")
endif()

if(WITH_SILO AND NOT Silo_FOUND)
  message(FATAL_ERROR "WITH_SILO selected, but FindSilo couldn't detect any installation of it.")
endif()

if(WITH_THREADS AND NOT OPENMP_FOUND)
message(FATAL_ERROR "WITH_THREADs selected, but no OpenMP support detected.")
endif()

if(WITH_VISIT)
  if (NOT VISIT_FOUND)
    message(FATAL_ERROR "WITH_VISIT selected, but no installation of VisIt could be found")
  endif()

  if (NOT PYTHONLIBS_FOUND)
    message(FATAL_ERROR "WITH_VISIT selected, but no Python libraries/headers could not be detected")
  endif()

  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${VisIt_INCLUDE_DIRS} ${PYTHON_INCLUDE_DIRS})
endif()

if(WIN32)
  set(LOCAL_LIBGEODECOMP_LINK_LIB local_libgeodecomp_lib)
else(WIN32)
  set(LOCAL_LIBGEODECOMP_LINK_LIB geodecomp)
endif(WIN32)

if(WITH_HPX)
  set(HPX_LIB_SUFFIX "")
  if("${CMAKE_BUILD_TYPE}" STREQUAL "Debug")
    set(HPX_LIB_SUFFIX ${HPX_DEBUG_POSTFIX})
    add_definitions(-DHPX_DEBUG)
  endif()
endif()

if(WITH_QT)
  include(${QT_USE_FILE})
  add_definitions(-DQT_NO_KEYWORDS)
  list(APPEND INSTALL_INCLUDE_DIRECTORIES ${QT_HEADERS_DIR})
endif()

include_directories(${INSTALL_INCLUDE_DIRECTORIES} ${BUILD_INCLUDE_DIRECTORIES})

#============= 6. TOP-LEVEL TARGETS ==================================
add_custom_target(check echo "Tests passed.")
add_custom_target(code_generation ALL echo "Code generation done.")
add_custom_target(doc cd "${CMAKE_CURRENT_SOURCE_DIR}" && doxygen doxygen.conf)

#============= 7. CPACK INSTALLER STUFF ==============================
set(CPACK_PACKAGE_NAME ${PACKAGE_NAME})
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY ${PACKAGE_NAME})
set(CPACK_PACKAGE_VERSION ${PACKAGE_VERSION})
set(CPACK_PACKAGE_INSTALL_DIRECTORY ${PACKAGE_NAME})

# will be shown e.g. in windows' control center package info
set(CPACK_PACKAGE_VENDOR ${PACKAGE_VENDOR})
set(CPACK_PACKAGE_DESCRIPTION_FILE "${CMAKE_CURRENT_SOURCE_DIR}/../README")
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/../LICENSE")
set(CPACK_PACKAGE_INSTALL_DIRECTORY ${PACKAGE_NAME})

if(WIN32 AND NOT UNIX)
  # unused in current nsis versions, fix pending (http://www.cmake.org/Bug/print_bug_page.php?bug_id=8682)
  set(CPACK_NSIS_DISPLAY_NAME ${PACKAGE_NAME})

  # name to show in software tab of control center
  set(CPACK_NSIS_DISPLAY_NAME ${PACKAGE_NAME})
  # will be shown e.g. in windows' control center package info
  set(CPACK_NSIS_HELP_LINK ${PACKAGE_HOMEPAGE})
  # will be shown e.g. in windows' control center package info
  set(CPACK_NSIS_URL_INFO_ABOUT ${PACKAGE_HOMEPAGE})
  # will be shown e.g. in windows' control center package info
  set(CPACK_NSIS_CONTACT ${PACKAGE_EMAIL})
  set(CPACK_NSIS_MODIFY_PATH ON)

  # There is a bug in NSI that does not handle full unix paths properly. Make
  # sure there is at least one set of four (4) backlasshes.
  set(CPACK_PACKAGE_ICON             "${CMAKE_SOURCE_DIR}/..\\libgeodecomp_icon.png")
  set(CPACK_NSIS_INSTALLED_ICON_NAME "${CMAKE_SOURCE_DIR}/..\\libgeodecomp_icon.png")
  # further options:
  #else(WIN32 AND NOT UNIX)
  #  set(CPACK_STRIP_FILES "bin/MyExecutable")
  #  set(CPACK_SOURCE_STRIP_FILES "")
  #  set(CPACK_PACKAGE_EXECUTABLES "helloworld" "My Hello World")
endif(WIN32 AND NOT UNIX)

include(CPack)

#============= 8. RECURSE SUBDIRS ====================================
set(HEADERS "")
set(SOURCES "")

foreach(dir ${SUBDIRS})
  add_subdirectory(${dir})
endforeach(dir)

foreach(dir ${AUXDIRS})
  set(HEADERS "")
  set(SOURCES "")
  include(${dir}/aux.cmake)
endforeach(dir)

#============= 9. ADD THE MAIN LIBRARY ===============================
if(WIN32)
  add_library(local_libgeodecomp_lib STATIC IMPORTED)
  set_property(TARGET local_libgeodecomp_lib PROPERTY IMPORTED_LOCATION ${LIBGEODECOMP_BINARY_DIR}/libgeodecomp/geodecomp.lib)
endif(WIN32)

# link all sources
set(SOURCES "")
foreach(dir ${LIBDIRS})
  set(RELATIVE_PATH ${dir}/)
  include(${dir}/auto.cmake)
endforeach(dir)

set(ALL_SOURCES ${SOURCES})
set(ALL_HEADERS ${HEADERS})

add_library(geodecomp ${LIB_LINKAGE_TYPE} ${SOURCES})
# CMake <2.8.11 doesn't have target_include_directories()
if(CMAKE_VERSION VERSION_GREATER 2.8.11)
  target_include_directories(geodecomp INTERFACE ${INSTALL_INCLUDE_DIRECTORIES})
  target_include_directories(geodecomp PRIVATE ${INSTALL_INCLUDE_DIRECTORIES} ${BUILD_INCLUDE_DIRECTORIES})
endif()

# link 3rd party libraries to main lib and add them to pkg-config file down below
set(LIBGEODECOMP_LINK_LIBRARIES ${ALL_BOOST_LIBS})
if(WITH_HPX)
  set(LIBGEODECOMP_LINK_LIBRARIES
    ${LIBGEODECOMP_LINK_LIBRARIES}
    hpx${HPX_LIB_SUFFIX}
    hpx_serialization${HPX_LIB_SUFFIX}
    hpx_init${HPX_LIB_SUFFIX}
    ${HPX_LIBRARIES})
endif()

if(WITH_SILO)
  set(LIBGEODECOMP_LINK_LIBRARIES
    ${LIBGEODECOMP_LINK_LIBRARIES}
    ${Silo_LIBRARY})
endif()

if(WITH_SCOTCH)
  set(LIBGEODECOMP_LINK_LIBRARIES
    ${LIBGEODECOMP_LINK_LIBRARIES}
    ${SCOTCH_LIBRARIES})
endif()

if(WITH_QT)
  set(LIBGEODECOMP_LINK_LIBRARIES
    ${LIBGEODECOMP_LINK_LIBRARIES}
    ${QT_LIBRARIES})
endif()

if(WITH_THREADS)
  if (WITH_LIBPTHREAD)
    # some systems (e.g. my devel notebook) require manually linking pthreads for OpenMP...
    if("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux")
      set(LIBGEODECOMP_LINK_LIBRARIES
        ${LIBGEODECOMP_LINK_LIBRARIES}
        pthread)
    endif()
  else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread")
  endif()
endif()

if(WITH_MPI)
  set(LIBGEODECOMP_LINK_LIBRARIES ${LIBGEODECOMP_LINK_LIBRARIES} ${MPI_LIBRARIES})
  set_property(TARGET geodecomp PROPERTY LINK_FLAGS ${MPI_LINK_FLAGS})
endif()

if(WITH_OPENCL)
  set(LIBGEODECOMP_LINK_LIBRARIES ${LIBGEODECOMP_LINK_LIBRARIES} OpenCL)
endif()

if(WITH_VISIT)
  set(LIBGEODECOMP_LINK_LIBRARIES ${LIBGEODECOMP_LINK_LIBRARIES} ${VisIt_LIBRARIES} ${PYTHON_LIBRARIES} dl)
endif()

target_link_libraries(geodecomp ${LIBGEODECOMP_LINK_LIBRARIES})

#============= 10. INSTALLER CONFIG ==================================
include(GNUInstallDirs)
install(
  TARGETS geodecomp
  EXPORT ${PACKAGE_NAME}-targets
  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})

install(FILES "${CMAKE_BINARY_DIR}/${PACKAGE_NAME}/config.h" DESTINATION include/${PACKAGE_NAME})
install(FILES libgeodecomp.h DESTINATION include)

# install all headers
foreach(dir ${LIBDIRS})
  set(HEADERS "")
  set(RELATIVE_PATH ${dir}/)
  include(${dir}/auto.cmake)
  install(FILES ${HEADERS} DESTINATION include/${PACKAGE_NAME}/${dir})
endforeach(dir)

# install libflatarray, too
file(GLOB HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/../lib/libflatarray/src/*.hpp")
foreach(i ${HEADERS})
  install(FILES ${i} DESTINATION include/libflatarray)
endforeach()
file(GLOB HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/../lib/libflatarray/src/detail/*.hpp")
foreach(i ${HEADERS})
  install(FILES ${i} DESTINATION include/libflatarray/detail)
endforeach()
file(GLOB HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/../lib/libflatarray/src/testbed/*.hpp")
foreach(i ${HEADERS})
  install(FILES ${i} DESTINATION include/libflatarray/testbed)
endforeach()

# link against the libs we need
set(INSTALLER_LINK_FLAGS "-L${CMAKE_INSTALL_PREFIX}/${LIB_DIR} -Wl,-rpath,${CMAKE_INSTALL_PREFIX}/${LIB_DIR} -lgeodecomp ")
foreach(lib ${LIBGEODECOMP_LINK_LIBRARIES})
  get_filename_component(path "${lib}" PATH)
  get_filename_component(name "${lib}" NAME)
  string(REGEX REPLACE "\\.so.*$" "" name "${name}")
  string(REGEX REPLACE "\\.a.*$" "" name "${name}")
  string(REGEX REPLACE "\\.dll.*$" "" name "${name}")

  if(name MATCHES ^lib)
    # this dirty trick is required to prevent REGEX REPLACE matching
    # every occurrence of "lib" ("^lib" will sadly match all, too, if
    # we're going to remove them)
    set(name "_dummy_${name}")
    string(REGEX REPLACE "_dummy_lib" "" name "${name}")
  endif()

  if (path)
    set(INSTALLER_LINK_FLAGS "${INSTALLER_LINK_FLAGS} -L${path} -Wl,-rpath,${path}")
  endif()
  set(INSTALLER_LINK_FLAGS "${INSTALLER_LINK_FLAGS} -l${name}")
endforeach()

set(PKG_CONFIG_INCLUDE_FLAGS "")
foreach(dir ${INSTALL_INCLUDE_DIRECTORIES})
  set(PKG_CONFIG_INCLUDE_FLAGS "${PKG_CONFIG_INCLUDE_FLAGS} -I${dir}")
endforeach()

file(WRITE "${CMAKE_BINARY_DIR}/${PACKAGE_NAME}.pc" "
Name: LibGeoDecomp
Description: High performance stencil code library
Version: ${PACKAGE_VERSION}
Libs: ${INSTALLER_LINK_FLAGS}
Cflags: -I${CMAKE_INSTALL_PREFIX}/include ${PKG_CONFIG_INCLUDE_FLAGS}
")
install(FILES "${CMAKE_BINARY_DIR}/${PACKAGE_NAME}.pc" DESTINATION "${LIB_DIR}/pkgconfig")

set(ConfigPackageLocation lib/cmake/${PACKAGE_NAME})

if(CMAKE_VERSION VERSION_GREATER 2.8.10)
  include(CMakePackageConfigHelpers)

  write_basic_package_version_file(
    "${CMAKE_CURRENT_BINARY_DIR}/../${PACKAGE_NAME}ConfigVersion.cmake"
    VERSION ${PACKAGE_VERSION}
    COMPATIBILITY AnyNewerVersion)

  install(
    FILES "${CMAKE_CURRENT_BINARY_DIR}/../${PACKAGE_NAME}ConfigVersion.cmake"
    DESTINATION "${ConfigPackageLocation}")
endif()

export(
  TARGETS geodecomp
  FILE "${CMAKE_CURRENT_BINARY_DIR}/../${PACKAGE_NAME}-targets.cmake")

# this config includes the current build tree and is meant for
# downstream projects which wish to include/link against a live build tree:
file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/../${PACKAGE_NAME}Config.cmake"

"
get_filename_component(LIBGEODECOMP_CMAKE_DIR \${CMAKE_CURRENT_LIST_FILE} PATH)
include(\"\${LIBGEODECOMP_CMAKE_DIR}/${PACKAGE_NAME}-targets.cmake\")

set(libgeodecomp_INCLUDE_DIRS
  ${BUILD_INCLUDE_DIRECTORIES}
  ${INSTALL_INCLUDE_DIRECTORIES}
)
")

# conversely, the to-be-installed config should not contain any
# references to the build tree:
file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_NAME}Config.cmake"

"
get_filename_component(LIBGEODECOMP_CMAKE_DIR \${CMAKE_CURRENT_LIST_FILE} PATH)
include(\"\${LIBGEODECOMP_CMAKE_DIR}/${PACKAGE_NAME}-targets.cmake\")

set(libgeodecomp_INCLUDE_DIRS
  \"\${LIBGEODECOMP_CMAKE_DIR}/../../../include\"
  ${INSTALL_INCLUDE_DIRECTORIES}
)
")

set(ConfigPackageLocation lib/cmake/${PACKAGE_NAME})
install(
  FILES "${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_NAME}Config.cmake"
  DESTINATION "${ConfigPackageLocation}")

install(EXPORT ${PACKAGE_NAME}-targets DESTINATION ${ConfigPackageLocation})

#============= 11. TYPEMAPS GENERATION ===============================
if (WITH_TYPEMAPS)
  set_directory_properties(PROPERTIES CLEAN_NO_CUSTOM true)

  add_custom_command(
    OUTPUT "${CMAKE_CURRENT_SOURCE_DIR}/communication/typemaps.h" "${CMAKE_CURRENT_SOURCE_DIR}/communication/typemaps.cpp"
    COMMAND cd "${CMAKE_CURRENT_SOURCE_DIR}" && doxygen doxygen.conf
    COMMAND ruby "${CMAKE_CURRENT_SOURCE_DIR}/../tools/typemapgenerator/generate.rb" --namespace LibGeoDecomp --header-fix "^.+/src:libgeodecomp" --macro-guard-mpi LIBGEODECOMP_WITH_MPI --macro-guard-boost LIBGEODECOMP_WITH_BOOST_SERIALIZATION "${CMAKE_CURRENT_SOURCE_DIR}/../doc/xml" "${CMAKE_CURRENT_SOURCE_DIR}/communication"
    DEPENDS "${CMAKE_BINARY_DIR}/cache")

  list(REMOVE_ITEM ALL_HEADERS "communication/typemaps.h")
  set(CANDIDATES)
  foreach(i ${ALL_HEADERS})
    set(CANDIDATES "${i}:${CANDIDATES}")
  endforeach(i)

  add_custom_command(
    OUTPUT "${CMAKE_BINARY_DIR}/cache"
    COMMAND cp -a "${CMAKE_BINARY_DIR}/last_cache" "${CMAKE_BINARY_DIR}/cache" 2>/dev/null || echo "still ok >/dev/null"
    COMMAND ruby "${CMAKE_CURRENT_SOURCE_DIR}/../tools/typemapgenerator/generate.rb" --cache "${CMAKE_BINARY_DIR}/cache" "${CMAKE_CURRENT_SOURCE_DIR}" "${CANDIDATES}"
    COMMAND cp -a "${CMAKE_BINARY_DIR}/cache" "${CMAKE_BINARY_DIR}/last_cache")
endif(WITH_TYPEMAPS)

set(LIBGEODECOMP_ALL_INCLUDE_DIRECTORIES ${BUILD_INCLUDE_DIRECTORIES} ${INSTALL_INCLUDE_DIRECTORIES} PARENT_SCOPE)
